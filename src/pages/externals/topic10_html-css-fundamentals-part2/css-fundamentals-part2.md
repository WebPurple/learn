---
title: Основы CSS. Часть 2
templateKey: 'article-page'
order: 2
tags: css, basics, fundamentals
---
<p align="center">
    <img
        width='100'
        title='CSS'
        src="../images/css3.svg"
    />
</p>

# Основы CSS. Часть 2

## Z-index

В CSS каждый блок имеет позицию в трех измерениях. В дополнение к горизонтальному и вертикальному положению, блоки выкладываются вдоль оси Z друг над другом. Положение вдоль оси Z особенно важно, когда блоки визуально накладываются друг на друга.

При позиционировании элементов они могут перекрывать друг друга. Свойство `z-index` определяет, какой элемент должен быть расположен спереди, а какой - сзади.

В некоторых случаях можно использовать свойство прозрачности `opacity`, чтобы добиться тех же результатов.

Если для элементов свойства `z-index` и `position` не заданы явно, браузер отображает элементы на странице в следующем порядке:

- Корневой элемент <html>, который содержит все элементы веб-странице.
- Блочные элементы, неплавающие и непозиционированные.
- Плавающие float непозиционированные элементы в порядке их расположения в исходном коде.
- Строковые непозиционированные элементы (текст, изображения).
- Позиционированные position элементы в порядке их следования в исходном коде. Последний из них будет расположен на переднем плане.

Свойство `z-index` позволяет изменить порядок наложения позиционированных элементов. Элементы будут отображаться на странице в следующем порядке (если для них не заданы свойства, влияющие на наложение — opacity, filter, transform):

- Корневой элемент <html>, который содержит все элементы веб-странице.
- Позиционированные элементы с отрицательным значением z-index.
- Блочные элементы, неплавающие и непозиционированные.
- Плавающие float непозиционированные элементы в порядке их расположения в исходном коде.
- Строковые непозиционированные элементы (текст, изображения).
- Позиционированные элементы со значениями z-index: 0; и z-index: auto;.

[example](http://jsbin.com/xupelekafe/edit?html,css,output)

## Overflow

Свойство `overflow` отвечает за отображение контента, выходящего за пределы своего контейнера.

[example](http://jsbin.com/fekume/edit?html,css,output)

## Скрытие элемента

Для скрытия элемента можно использовать разные методы.

-   `display: none;`

-   `visibility: hidden;`

-   `opacity: 0;`

-   и др.

[example](http://jsbin.com/saxupaf/edit?html,css,output)

Важно заметить, что есть отличия в перечисленных способах. <br />

В случае `display: none;` элемент выбивается из потока документа. Он не доступен пользователю ни с клавиатуры, ни с какого-либо другого устройства. Элемента как будто бы нет.

`visibility: hidden;` остается в потоке документа, занимает место на экране и его будут обтекать другие элементы. Функционал, размещенный внутри блока, недоступен.

 `opacity: 0;` - самый опасный способ. Элемент прозрачен, занимает место на экране, весь функционал доступен (Если спрятана ссылка, то пользователь может кликнуть на нее и перейти на ресурс) 

## Clip-path

В компьютерной графике отсечение и маскирование — это две наиболее используемые операции. Обе они визуально скрывают часть элемента. Отсечение определяет область элемента которая будет видна, всё остальное за пределами этой области не отображается и получается «отрезанным».<br />
Существует два способа использования `clip-path`.<br />

1. на CSS<br />
Основные фигуры из «CSS Shapes Module» обеспечивают удобный способ использования clip-path. Доступны разные фигуры: polygon, circle, ellipse и inset; inset предназначен для прямоугольников.

2. на SVG<br />
В качестве альтернативы можно создать фигуру с помощью SVG, а затем обрезать элемент по этой фигуре с помощью синтаксиса URL. 

Есть два способа сделать это:
- через указатель на встроенный SVG (то есть разметка SVG существует в самой странице);
- со ссылкой на внешний документ SVG.

Свойство clip-path принимает значения базовых векторных форм (circle, ellipse, inset, polygon) или svg-элементы clippingPath. <br />
Существует старое свойство `clip` из CSS 2.1, которое довольно ограниченно, хотя бы потому, что оно поддерживает только прямоугольные фигуры. 

[Это свойство](https://developer.mozilla.org/en-US/docs/Web/CSS/clip-path) определяет область элемента, которая должна быть показана. Вырезаемая область определяется или URL, относящимся к SVG, или формой, например, [circle()](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/circle).

[Конструктор](https://bennettfeely.com/clippy/).

## Mask

Альтернативный способ вырезать область - [свойство `mask`](https://developer.mozilla.org/en-US/docs/Web/CSS/mask). Оно также [не поддерживается в IE, Edge и Opera](https://caniuse.com/#search=mask).
 
При маскировании изображение маски объединяется с элементом. Части маскированного элемента получаются полностью или частично прозрачными. Новая спецификация CSS Masking направлена на объединение этих двух операций в мире HTML.<br />
Свойства `mask-image` и `mask-box-image` принимают растровые маски двух типов (с альфа-каналом и luminance-маски), они очень похожи, но заставить работать в webkit-браузерах удалось только alpha. 

[example](http://jsbin.com/kigepuzezo/edit?html,css,output)

## @-rules

@-правило - это инструкция CSS. Каждая инструкция начинается с `@` и содержит одно из ключевых слов.

### @font-face

Данное правило позволяет загружать на веб-страницу специальные шрифты. Правило указывает браузеру скачать шрифт из указанного источника и затем отобразить его, как определено в CSS.

```css
@font-face {
    font-family: 'My Web Font';
    src: url('https://fonts.gstatic.com/s/gloriahallelujah/v8/CA1k7SlXcY5kvI81M_R28cNDay8z-hHR7F16xrcXsJw.woff2');
}

body {
    font-family: 'My Web Font', 'Open Sans', cursive;
}
```

### @import

Это правило обычно указывается в начале файла и указывает на включение внешнего CSS-файла. При этом содержимое внешнего файла вставляется на строку, где указано правило.

[example](http://jsbin.com/rakevu/edit?html,css,output)

### @media

Это правило содержит условия для определения стилей для разных экранов. Условия могут содержать размеры экранов, что очень полезно для адаптивной верстки.

```css
@media not|only mediatype and (media feature) {
    CSS-Code;
}
```

Медиатипы:

<table>
    <tbody>
    <tr>
        <th style="width: 25%;">Значение</th>
        <th>Описание</th>
    </tr>
    <tr>
        <td>all</td>
        <td>Устройства любого медиа-типа</td>
    </tr>
    <tr>
        <td>print</td>
        <td>Принтеры</td>
    </tr>
    <tr>
        <td>screen</td>
        <td>Экраны компьютеров, планшетов, смартфоном и т.д.</td>
    </tr>
    <tr>
        <td>speech</td>
        <td>Скринридеры</td>
    </tr>
    </tbody>
</table>

Медиа функции:

<table>
    <tbody>
    <tr>
        <th style="width: 277px;">Критерий</th>
        <th>Значение критерия</th>
    </tr>
    <tr>
        <td style="width: 277px;">max-height</td>
        <td>Максимальная высота показываемой области, например, окна браузера</td>
    </tr>
    <tr>
        <td style="width: 277px;">max-width</td>
        <td>Максимальная ширина показываемой области, например, окна браузера</td>
    </tr>
    <tr>
        <td style="width: 277px;">min-height</td>
        <td>Минимальная высота показываемой области, например, окна браузера</td>
    </tr>
    <tr>
        <td style="width: 277px;">min-width</td>
        <td>Минимальная ширина показываемой области, например, окна браузера</td>
    </tr>
    <tr>
        <td style="width: 277px;">orientation</td>
        <td>Ориентация (портретная или ландшафтная)</td>
    </tr>
    </tbody>
</table>

[Подробнее о медиа-запросах](http://htmlbook.ru/css/value/media).

[Адаптивный дизайн](https://webref.ru/layout/advanced-html-css/responsive-web-design).

[example](http://jsbin.com/vetoce/edit?html,css,output)
